---
title: Query Graph Data
description: Perform common graph data queries and supplement those queries with the execution step using Azure Cosmos DB for Apache Gremlin.
ms.topic: how-to
ms.date: 07/23/2025
ai-usage: ai-generated
---

# Query Graph Data in Azure Cosmos DB for Apache Gremlin

The Azure Cosmos DB for Apache Gremlin supports the [Gremlin TinkerPop](https://tinkerpop.apache.org/gremlin.html) syntax for queries. This guide walks through common queries that can be performed using this service. You can run following queries in this guide using the [Gremlin console](https://tinkerpop.apache.org/docs/current/reference/#gremlin-console), or your favorite Gremlin driver.

## Prerequisites

[!INCLUDE[Prerequisites - Account with sample data](includes/prerequisites-account-sample-data.md)]\

## Count the number of vertices in the graph

Count the total number of vertices in the graph. This operation is useful for understanding the size of your dataset or validating data loads.

```gremlin
g.V().count()
```

## Filter vertices by label and property

Retrieve vertices that match a specific label and property value. This query is helpful for narrowing down results to a subset of interest, such as people over a certain age.

```gremlin
g.V().hasLabel('person').has('age', gt(40))
```

## Project specific properties from vertices

Return only selected properties from the matched vertices. This query reduces the amount of data returned and focuses on relevant fields, such as names.

```gremlin
g.V().hasLabel('person').values('name')
```

## Find related edges and vertices

Find related entities by traversing the graph. For example, find all friends of a specific person by traversing outgoing edges and then to the connected vertices.

```gremlin
g.V('thomas').outE('knows').inV().hasLabel('person')
```

To find friends of friends, perform two hops in the traversal:

```gremlin
g.V('thomas').outE('knows').inV().hasLabel('person').outE('knows').inV().hasLabel('person')
```

## Analyze query execution with execution profile

Analyze the performance and execution details of a Gremlin query using the `executionProfile()` step. This step returns a JSON object with metrics for each step in the query, which helps with troubleshooting and optimization.

```gremlin
g.V('mary').out().executionProfile()
```

```json
[
  {
    "gremlin": "g.V('mary').out().executionProfile()",
    "totalTime": 28,
    "metrics": [
      {
        "name": "GetVertices",
        "time": 24,
        "annotations": { "percentTime": 85.71 },
        "counts": { "resultCount": 2 },
        "storeOps": [ { "fanoutFactor": 1, "count": 2, "size": 696, "time": 0.4 } ]
      },
      {
        "name": "GetEdges",
        "time": 4,
        "annotations": { "percentTime": 14.29 },
        "counts": { "resultCount": 1 },
        "storeOps": [ { "fanoutFactor": 1, "count": 1, "size": 419, "time": 0.67 } ]
      },
      {
        "name": "GetNeighborVertices",
        "time": 0,
        "annotations": { "percentTime": 0 },
        "counts": { "resultCount": 1 }
      },
      {
        "name": "ProjectOperator",
        "time": 0,
        "annotations": { "percentTime": 0 },
        "counts": { "resultCount": 1 }
      }
    ]
  }
]
```

For more information about the `executionProfile()` step, see [execution profile reference](reference-execution-profile.md).

> [!TIP]
> The `executionProfile()` step executes the Gremlin query. This query includes the `addV` or `addE` steps, which results in the creation and commit of the changes specified in the query. Request units generated by the Gremlin query are also charged.

## Identify blind fan-out query patterns

A blind fan-out occurs when a query accesses more partitions than necessary, often due to missing partition key predicates. This antipattern can increase latency and cost. The execution profile helps identify such patterns by showing a high `fanoutFactor`.

```gremlin
g.V('tt0093640').executionProfile()
```

```json
[
  {
    "gremlin": "g.V('tt0093640').executionProfile()",
    "totalTime": 46,
    "metrics": [
      {
        "name": "GetVertices",
        "time": 46,
        "annotations": { "percentTime": 100 },
        "counts": { "resultCount": 1 },
        "storeOps": [ { "fanoutFactor": 5, "count": 1, "size": 589, "time": 75.61 } ]
      },
      {
        "name": "ProjectOperator",
        "time": 0,
        "annotations": { "percentTime": 0 },
        "counts": { "resultCount": 1 }
      }
    ]
  }
]
```

## Optimizing fan-out queries

A high `fanoutFactor` (such as 5) indicates the query accessed multiple partitions. To optimize, include the partition key in the query predicate:

```gremlin
g.V('tt0093640').has('partitionKey', 't1001')
```

## Unfiltered query pattern

Unfiltered queries could process a large initial dataset, increasing cost and latency.

Unfiltered query:

```gremlin
g.V().hasLabel('tweet').out().executionProfile()
```

```json
[
  {
    "gremlin": "g.V().hasLabel('tweet').out().executionProfile()",
    "totalTime": 42,
    "metrics": [
      {
        "name": "GetVertices",
        "time": 31,
        "annotations": { "percentTime": 73.81 },
        "counts": { "resultCount": 30 },
        "storeOps": [ { "fanoutFactor": 1, "count": 13, "size": 6819, "time": 1.02 } ]
      },
      {
        "name": "GetEdges",
        "time": 6,
        "annotations": { "percentTime": 14.29 },
        "counts": { "resultCount": 18 },
        "storeOps": [ { "fanoutFactor": 1, "count": 20, "size": 7950, "time": 1.98 } ]
      },
      {
        "name": "GetNeighborVertices",
        "time": 5,
        "annotations": { "percentTime": 11.9 },
        "counts": { "resultCount": 20 },
        "storeOps": [ { "fanoutFactor": 1, "count": 4, "size": 1070, "time": 1.19 } ]
      },
      {
        "name": "ProjectOperator",
        "time": 0,
        "annotations": { "percentTime": 0 },
        "counts": { "resultCount": 20 }
      }
    ]
  }
]
```

## Filtered query pattern

Adding filters before traversals can reduce the working set and improve performance. The execution profile shows the effect of filtering.

```gremlin
g.V().hasLabel('tweet').has('lang', 'en').out().executionProfile()
```

```json
[
  {
    "gremlin": "g.V().hasLabel('tweet').has('lang', 'en').out().executionProfile()",
    "totalTime": 14,
    "metrics": [
      {
        "name": "GetVertices",
        "time": 14,
        "annotations": { "percentTime": 58.33 },
        "counts": { "resultCount": 11 },
        "storeOps": [ { "fanoutFactor": 1, "count": 11, "size": 4807, "time": 1.27 } ]
      },
      {
        "name": "GetEdges",
        "time": 5,
        "annotations": { "percentTime": 20.83 },
        "counts": { "resultCount": 18 },
        "storeOps": [ { "fanoutFactor": 1, "count": 18, "size": 7159, "time": 1.7 } ]
      },
      {
        "name": "GetNeighborVertices",
        "time": 5,
        "annotations": { "percentTime": 20.83 },
        "counts": { "resultCount": 18 },
        "storeOps": [ { "fanoutFactor": 1, "count": 4, "size": 1070, "time": 1.01 } ]
      },
      {
        "name": "ProjectOperator",
        "time": 0,
        "annotations": { "percentTime": 0 },
        "counts": { "resultCount": 18 }
      }
    ]
  }
]
```

The filtered query processes fewer vertices, resulting in lower latency and cost.
